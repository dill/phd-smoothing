% Speeding up MDS
% David Lawrence Miller
% d.l.miller@bath.ac.uk
  
\documentclass[a4paper,10pt]{article}
\setlength{\textheight}{22.5cm}
\setlength{\textwidth}{6.47in}
\setlength{\oddsidemargin}{-1mm}
\setlength{\topmargin}{0.1cm}
\setlength{\evensidemargin}{-5mm} 
 
% Load some packages
\usepackage{times, amsmath, amssymb, amsfonts, url, natbib, bm, rotating}
 
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{rotating}

% top matter
\title{Improvements to the MDS+TPRS approach}
\author{David Lawrence Miller\\Mathematical Sciences\\University of Bath\\\texttt{d.l.miller@bath.ac.uk}}
 
% Shortcuts
% Probability
\newcommand{\prob}[1]{\mathbb{P}\left[ #1 \right]}
% Schwarz-Christoffel
\newcommand{\sch}{Schwarz-Christoffel }
% fprime
\newcommand{\fprime}{f^\prime(z)}
% figure reference command
\newcommand{\fig}[1]{\emph{fig.} \ref{#1}}
% Figure reference command
\newcommand{\Fig}[1]{\emph{Fig.} \ref{#1}}
% table reference command
\newcommand{\tabref}[1]{\emph{table} \ref{#1}}
% Table reference command
\newcommand{\Tabref}[1]{\emph{Table} \ref{#1}}
% equation reference command
\newcommand{\eqn}[1]{(\ref{#1})}
% phi inverse
\newcommand{\phiinv}{\phi^{-1}}
% use other phi
\renewcommand{\phi}{\varphi}
%transpose
\newcommand{\tr}[1]{#1^{\text{T}}}
% diagonal
\newcommand{\diag}{\text{diag}}
% call \times \cross
\newcommand{\cross}{\times}


\begin{document}
 
% The abstract
%\begin{abstract}
%Here.
%\end{abstract}
 
 
% New theorem for theorems
\newtheorem{thm}{Theorem}[section]
 
%New theorem for definitions
\newtheorem{defn}{Definition}[section]
 
\maketitle

\section{Introduction}

Clearly need to speed up. Also make things more accurate.

Following from the conclusions of the 12 month report, it seems that the main aims from here should be to speed up the algorithm for calculating the within-area distances and to adjust the 


\section{Calculating MDS by Lanczos iteration}

This should be simple enough, just re-write \texttt{cmdscale} so that only the first $k$ eigenvalues are computed, rather than finding $n$, returning $k$ of them and discarding the rest.

\section{Partial path calculation}

Previous algorithm slow. Want to speed this up. 

NEED TO THINK ABOUT: do we want to store Euclidean paths? Why? Always more expensive.


Outline: Use sparse grid, calculate paths there, then hook up the new points onto pre-calculated paths there. Hope to get rid of the main part of the calculation (ie. the modifications in the middle where the action hopefully happens.)

Notation is as in algorithm for the path calculation. Taking points $p_i$ and $p_j$ in the set of points in the domain that we wish to find the shortest paths for and drawing a path between them, finding within-area distance with respect to the boundary of $\Gamma$.

This is a modification of the the original algorithm, the routines INIT, DELETE, ALTER, ITER are identical.

\begin{enumerate}
 \item Begin by creating a sparse grid within $\Gamma$ and calculate the non-Euclidean within-area paths between all pairs of points exactly as in algorithm 1. Store these paths as they are calculated as $\mathcal{P}_1,\ldots, \mathcal{P}_M$.
 
\item For each unique pairing of $p_i$ and $p_j$ in the full data set calculate the path use one of the following:

\begin{enumerate}

\item Find a $\mathcal{P}_k$ such that the path between $p_i$ and one end of $\mathcal{P}_k$ and $p_j$ and the other end of $\mathcal{P}_k$ is Euclidean within the $\Gamma$. Join $p_i$ and $p_j$ onto the appropriate ends of $\mathcal{P}_k$ and run ITER until convergence.

\item If there is no Euclidean path between $p_i$ and $p_j$ and any of the ends of $\mathcal{P}_k$, then use the algorithm 1 to calculate the path between $p_i$ and $p_j$. 

\end{enumerate}
\end{enumerate}


\subsection{Results}

Comparison to results in previous report.


\begin{table}[ht]
\centering
\begin{tabular}{c || c c c}
 & MDS & Soap film & Thin plate\\ 
\hline
Fit & 3.39225 & 10.87688 & 0.61492\\
Prediction & 4.80357 & 8.87535 & 0.10845\\
\end{tabular}
\label{ramsaytime}
\caption{Average time (in seconds) to fit a realisation of the modified Ramsay horseshoe for the three models considered above. Times are averaged over 100 realisations and were found using the elapsed time provided by \textsf{R}'s built-in \texttt{system.time} function.}
\end{table}


\begin{table}[ht]
\centering
\begin{tabular}{c || c c c c c c}
%  no speedup           speedup
 & MDS & MDS (tensor) & MDS (\textit{pp})& MDS (tensor) (\textit{pp})& Soap film & Thin plate\\ 
\hline
Fit & & & 18.6526 & 19.1409 & 24.6783 & 0.4022\\ 
Prediction & & & 53.5105 & 53.4204 & 29.3946 & 0.1249\\
\end{tabular}
\label{wt2time}
\caption{Average time (in seconds) to fit and predict on a realisation of the peninsula domain for the four models considered above. Times are averaged over 100 realisations and were found using the elapsed time provided by \textsf{R}'s built-in \texttt{system.time} function. For each realisation a sample of size 250 was taken, then a 1253 values were predicted. For the MDS+TPRS models \textit{pp} indicates the cases where the partial paths were pre-calculated, those not marked use algorithm 1.}
\end{table}

% old
%Fit & 84.85242 & 85.35168 & 36.24865 & 0.51721\\
%Prediction & 155.4004 & 155.2419 & 44.22065 & 0.20994 \\









\section{Clever grids}

Initial grid calculations could be done on a much less dense grid, making things much faster. Possibly just shrinking the polygon and using points on the edges.



\section{Dynamic $\lambda$}


\begin{equation}
\lambda \int\int \mathsf{K}(x,y) \Big( \Big(\frac{\partial^2 f(x,y)}{\partial x^2}\Big)^2 + 2\Big(\frac{\partial^2 f(x,y)}{\partial y \partial x}\Big) + \Big(\frac{\partial^2 f(x,y)}{\partial y^2}\Big)^2 \text{d}x\text{d}y
\end{equation}


\begin{table}[ht]
\centering
\begin{tabular}{c c c c c c c c c c}
 & & MSE & &  & EDF & \\ 
 & MDS & MDS (tensor) & soap & thin plate & MDS & MDS (tensor) & soap & thin plate\\ 
0.05  & 0.0354 (0.00033) & 0.0814 (0.01172) & 0.0238 (0.00031) &0.0508 (0.00031) &89.4217 (0.17576) & 87.5388 (0.67077) & 93.8112 (0.85755) & 87.0515 (0.85755)\\ 
0.5  & 0.1015 (0.00082) & 0.0872 (0.00122) & 0.0761 (0.00091) &0.1102 (0.00091) &57.3566 (0.52471) & 45.6116 (0.39864) & 45.1661 (0.69063) & 58.4121 (0.69063)\\ 
5  & 0.9818 (0.03089) & 1.3047 (0.0431) & 1.2253 (0.03584) &1.4379 (0.03584) &7.0495 (0.31291) & 9.6196 (0.39957) & 11.1636 (0.59128) & 12.1361 (0.59128)\\ 
\end{tabular}
\end{table}


\section{3D?}

\section{Aral sea}


\bibliographystyle{plainnat}
\bibliography{mds-refs}

\end{document}
